using System;
using System.Runtime.InteropServices;

namespace mstat.Core.Win32
{
    public static class Imports
    {
        /// <summary>
        ///     Retrieves the specified value from the WNDCLASSEX structure associated with the specified window.
        /// </summary>
        /// <param name="hWnd">A handle to the window and, indirectly, the class to which the window belongs.</param>
        /// <param name="nIndex">The value to be retrieved. To retrieve a value from the extra class memory, specify
        /// the positive, zero-based byte offset of the value to be retrieved.</param>
        /// <returns>
        ///     If the function succeeds, the return value is the requested value.
        ///     If the function fails, the return value is zero. To get extended error information, call GetLastError.
        /// </returns>
        /// <remarks>
        ///     https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getclasslongptra
        /// </remarks>
        [DllImport("user32.dll", EntryPoint = "GetClassLong")]
        internal static extern uint GetClassLong32(IntPtr hWnd, int nIndex);
        
        /// <summary>
        /// <inheritdoc cref="GetClassLong32"/>
        /// </summary>
        [DllImport("user32.dll", EntryPoint = "GetClassLongPtr")]
        internal static extern IntPtr GetClassLong64(IntPtr hWnd, int nIndex);

        /// <summary>
        ///     Destroys an icon and frees any memory the icon occupied.
        /// </summary>
        /// <param name="handle">A handle to the icon to be destroyed. The icon must not be in use.</param>
        /// <returns>
        ///     If the function succeeds, the return value is nonzero.
        ///     If the function fails, the return value is zero.To get extended error information, call GetLastError.
        /// </returns>
        /// <remarks>
        ///     https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-destroyicon
        /// </remarks>
        [DllImport("user32.dll", CharSet = CharSet.Auto)]
        internal static extern bool DestroyIcon(IntPtr handle);

        // TODO: This import is missing from P/Invoke
        /// <summary>
        ///     Removes an event hook function created by a previous call to SetWinEventHook.
        /// </summary>
        /// <param name="hWinEventHook">Handle to the event hook returned in the previous call to SetWinEventHook</param>
        /// <returns>
        ///     If successful, returns true; otherwise, returns false. (Ba dum tss!)
        /// </returns>
        /// <remarks>
        ///     https://docs.microsoft.com/hu-hu/windows/win32/api/winuser/nf-winuser-unhookwinevent
        /// </remarks>
        [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        internal static extern bool UnhookWinEvent(IntPtr hWinEventHook);

        // TODO: Also this import is missing from P/Invoke too
        /// <summary>
        ///     Removes an event hook function created by a previous call to SetWinEventHook.
        /// </summary>
        /// <param name="hWindowsHook">Handle to the event hook returned in the previous call to SetWindowsHookEx</param>
        /// <returns>If successful, returns true; otherwise, returns false. (Ba dum tss!)</returns>
        [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        internal static extern bool UnhookWindowsHookEx(IntPtr hWindowsHook);

        // TODO: Find workaround for the problem mentioned below
        // PInvoke.User32 already contains a definition for WinEventProc but with a SafeEventHookHandle to the #1 parameter
        // SafeHandles cannot be marshaled from unmanaged to managed. Therefore I had to make my own delegate 
        /// <summary>
        ///     An application-defined callback (or hook) function that the system calls in response to events generated by 
        ///     an accessible object. The hook function processes the event notifications as required. Clients install the 
        ///     hook function and request specific types of event notifications by calling SetWinEventHook.
        /// </summary>
        /// <param name="hWinEventHook">Handle to an event hook function. This value is returned by SetWinEventHook when the 
        /// hook function is installed and is specific to each instance of the hook function.</param>
        /// <param name="eventType">Specifies the event that occurred. This value is one of the event constants.</param>
        /// <param name="hWnd">Handle to the window that generates the event, or NULL if no window is associated with the event.
        /// For example, the mouse pointer is not associated with a window.</param>
        /// <param name="idObject">Identifies the object associated with the event. This is one of the object identifiers or a
        /// custom object ID.</param>
        /// <param name="idChild">Identifies whether the event was triggered by an object or a child element of the object.
        /// If this value is CHILDID_SELF, the event was triggered by the object; otherwise, this value is the child ID of
        /// the element that triggered the event.</param>
        /// <param name="dwEventThread"></param>
        /// <param name="dwMsEventTime">Specifies the time, in milliseconds, that the event was generated.</param>
        /// <remarks>
        ///     https://docs.microsoft.com/en-us/windows/win32/api/winuser/nc-winuser-wineventproc
        /// </remarks>
        internal delegate void WinEventProcEx(IntPtr hWinEventHook, uint eventType, IntPtr hWnd, int idObject, int idChild, int dwEventThread, uint dwMsEventTime);
    }
}
